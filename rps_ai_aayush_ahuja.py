# -*- coding: utf-8 -*-
"""RPS AI - Aayush Ahuja

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SIZm9z0a62ytYHP0svrY9raMpoz2FX5x
"""

from google.colab import drive

drive.mount("/content/gdrive", force_remount=True)

### Name Project folder
proj_name = 'rps'
###
proj_path = '/content/gdrive/My Drive/'+proj_name+'/train'
proj_path
# this will print put the folder where the images and models should reside
# to switch to a different image set change the proj_name value to the new folder on My Drive

#%mkdir $proj_path
## commented out since these have already been created

#%mkdir {proj_path+'/rock'}

#%mkdir {proj_path+'/paper'}

#%mkdir {proj_path+'/scissors'}

# Commented out IPython magic to ensure Python compatibility.
## Change the current directory to view the subfolders
# %cd $proj_path
# %ls

from IPython.display import display, Javascript
from google.colab.output import eval_js
from base64 import b64decode

def take_photo(filename='photo.jpg', quality=0.8):
  js = Javascript('''
    async function takePhoto(quality) {
      const div = document.createElement('div');
      const capture = document.createElement('button');
      capture.textContent = 'Capture';
      div.appendChild(capture);

      const video = document.createElement('video');
      video.style.display = 'block';
      const stream = await navigator.mediaDevices.getUserMedia({video: true});

      document.body.appendChild(div);
      div.appendChild(video);
      video.srcObject = stream;
      await video.play();

      // Resize the output to fit the video element.
      google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

      // Wait for Capture to be clicked.
      await new Promise((resolve) => capture.onclick = resolve);

      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      stream.getVideoTracks()[0].stop();
      div.remove();
      return canvas.toDataURL('image/jpeg', quality);
    }
    ''')
  display(js)
  data = eval_js('takePhoto({})'.format(quality))
  binary = b64decode(data.split(',')[1])
  with open(filename, 'wb') as f:
    f.write(binary)
  return filename

from IPython.display import Image

### Choose these parameters
# maxRock - number of images taken with "rock" gesture
# maxPaper - number of images taken with "paper" gesture
# maxScissors - number of images taken with "scissors" gesture
###

maxRock = 5
maxPaper = 5
maxScissors = 5

### End initialization
###
try:
  ct = int(1)
  maxPaper = maxRock + maxPaper
  maxScissors = maxPaper + maxScissors
  while True:
    if ct <= maxRock:
      print("Show Rock and press Capture!")
      label = "rock"
    elif ct <= maxPaper:
      print("Show Paper and press Capture!")
      label = "paper"
    else:
      print("Show Scissors and press Capture!")
      label = "scissors"

    filename = take_photo(label + "/" +label+'_'+str(ct))

    print('Saved to {}'.format(filename))

    ct += 1
    if ct > maxScissors:
      break
except Exception as err:
  # Errors will be thrown if the user does not have a webcam or if they do not
  # grant the page permission to access it.
  print(str(err))

import os
from google.colab import drive
import datetime

# Record the start time for performance evaluation
start_time = datetime.datetime.now()

# Initialize Google Drive for storing and accessing data directly
drive.mount('/content/gdrive')
root_dir = '/content/gdrive/My Drive/'
rps_dir = os.path.join(root_dir, 'rps')
train_dir = os.path.join(rps_dir, 'train')
test_dir = os.path.join(rps_dir, 'test')
model_dir = os.path.join(root_dir, 'model')
os.makedirs(model_dir, exist_ok=True)

# Ensure the data directory exists
if not os.path.exists(rps_dir):
    raise FileNotFoundError(f"Directory {rps_dir} does not exist.")
print(f"'rps' directory contents: {os.listdir(rps_dir)}")

# Load training data
import glob

print(f"Train directory: {train_dir}")
print(f"Test directory: {test_dir}")

print(f"Number of train scissors images: {len(glob.glob(f'{train_dir}/paper/*.jpg'))}")
print(f"Number of train rock images: {len(glob.glob(f'{train_dir}/rock/*.jpg'))}")
print(f"Number of train paper images: {len(glob.glob(f'{train_dir}/paper/*.jpg'))}")

print(f"Number of test scissors images: {len(glob.glob(f'{test_dir}/paper/*.jpg'))}")
print(f"Number of test rock images: {len(glob.glob(f'{test_dir}/rock/*.jpg'))}")
print(f"Number of test paper images: {len(glob.glob(f'{test_dir}/paper/*.jpg'))}")

from os import listdir, rename
from os.path import isfile, join
from PIL import Image
from os.path import splitext

def process_images(proj_path):
    for label in ['rock', 'paper', 'scissors']:
        for i in [f for f in listdir(join(proj_path, label)) if isfile(join(proj_path, label, f))]:
            file_path = join(proj_path, label, i)
            file_name, file_ext = splitext(i)

            try:
                im = Image.open(file_path)
                im = im.resize((640, 480))

                if file_ext.lower() in ['.png', '.jpeg']:
                    # Convert RGBA to RGB if the image has an alpha channel
                    if im.mode == 'RGBA':
                        im = im.convert('RGB')
                    new_file_path = join(proj_path, label, f"{file_name}.jpg")
                    im.save(new_file_path, 'jpeg')
                    print(f"Successfully Converted {i} to {file_name}.jpg")
                    # Optionally, remove the original file
                    # os.remove(file_path)
                else:
                    new_file_path = join(proj_path, label, f"{file_name}.jpg")
                    im.save(new_file_path, 'jpeg')
                    print(f"Successfully Resized {i} and saved as {file_name}.jpg")

            except Exception as e:
                print(f"Error processing file {i} at {file_path}: {e}")
                # Rename the problematic file with 'z_' prefix
                new_file_path = join(proj_path, label, f"z_{i}")
                rename(file_path, new_file_path)
                print(f"Renamed problematic file {i} to z_{i}")

# Example usage:

process_images(test_dir)

process_images(train_dir)

import os

def renumber_images(base_path):
    categories = ['rock', 'paper', 'scissors']
    for category in categories:
        # Renumber images in the train folder
        train_path = os.path.join(base_path, 'train', category)
        renumber_folder(train_path, category)

        # Renumber images in the test folder
        test_path = os.path.join(base_path, 'test', category)
        renumber_folder(test_path, category)

def renumber_folder(folder_path, class_name):
    if not os.path.exists(folder_path):
        print(f"Folder not found: {folder_path}")
        return

    files = os.listdir(folder_path)
    files.sort()  # Sort to maintain a consistent order

    # First, rename all files to a temporary name
    temp_files = []
    for idx, filename in enumerate(files, start=1):
        file_path = os.path.join(folder_path, filename)
        if os.path.isfile(file_path):
            temp_filename = f"temp_{class_name}_{idx:05d}.jpg"
            temp_file_path = os.path.join(folder_path, temp_filename)
            os.rename(file_path, temp_file_path)
            temp_files.append(temp_filename)

    # Then, rename all temporary files to the final name
    for idx, temp_filename in enumerate(temp_files, start=1):
        temp_file_path = os.path.join(folder_path, temp_filename)
        if os.path.isfile(temp_file_path):
            new_filename = f"{class_name}_{idx}.jpg"
            new_file_path = os.path.join(folder_path, new_filename)
            os.rename(temp_file_path, new_file_path)
            print(f"Renamed {temp_file_path} to {new_file_path}")

# Path to your dataset
renumber_images(rps_dir)

from tensorflow.keras.preprocessing.image import ImageDataGenerator
# Define a custom preprocessing function to ensure uniform image sizes and shapes
def make_square_and_resize(image):
    """Pad an image to make it square and resize it to (224, 224)."""
    target_size = (224, 224)
    height, width = image.shape[:2]
    delta_w = max(height - width, 0)
    delta_h = max(width - height, 0)
    top, bottom = delta_h // 2, delta_h - (delta_h // 2)
    left, right = delta_w // 2, delta_w - (delta_w // 2)
    color = [255, 255, 255]  # white background for padding
    new_img = cv2.copyMakeBorder(image, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)
    new_img = cv2.resize(new_img, target_size)
    return new_img

# Prepare image data generators with real-time augmentation and custom preprocessing
train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest',
    preprocessing_function=make_square_and_resize
)
test_datagen = ImageDataGenerator(rescale=1./255, preprocessing_function=make_square_and_resize)

# Load images from directories and prepare them for training and validation
train_generator = train_datagen.flow_from_directory(train_dir, target_size=(224, 224), batch_size=32, class_mode='categorical')
test_generator = test_datagen.flow_from_directory(test_dir, target_size=(224, 224), batch_size=32, class_mode='categorical')

# Get the number of training images
num_train_images = train_generator.samples
print(f"Number of training images: {num_train_images}")

# Get the number of testing images
num_test_images = test_generator.samples
print(f"Number of testing images: {num_test_images}")